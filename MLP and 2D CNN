import numpy as np
import matplotlib.pyplot as plt
import rasterio
import tensorflow as tf

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import (
    mean_squared_error, mean_absolute_error, accuracy_score, roc_auc_score
)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import (
    Dense, Dropout, BatchNormalization, Conv2D, MaxPooling2D, Flatten, InputLayer
)
from tensorflow.keras.optimizers import Adam
from sklearn.neural_network import MLPRegressor

# Ensure reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# -------------------------
# Utility Functions
# -------------------------

def read_geotiff(file_path):
    """Read a single-band GeoTIFF file into a numpy array."""
    with rasterio.open(file_path) as src:
        return src.read(1)

def stack_env_factors(env_factors):
    """Stack multiple environmental factors into shape (H, W, C)."""
    return np.stack(env_factors, axis=-1)

def generate_feature_matrix(env_factors):
    """Flatten environmental factors into a feature matrix (N, C)."""
    num_rows, num_cols = env_factors[0].shape
    feature_matrix = np.zeros((num_rows * num_cols, len(env_factors)))
    for i, factor in enumerate(env_factors):
        feature_matrix[:, i] = factor.flatten()
    return feature_matrix, num_rows, num_cols

def evaluate_performance(y_true, y_pred, threshold=0.5):
    """Compute regression + classification metrics."""
    mse = mean_squared_error(y_true, y_pred)
    mae = mean_absolute_error(y_true, y_pred)

    y_pred_bin = (y_pred > threshold).astype(int)
    y_true_bin = (y_true > threshold).astype(int)

    accuracy = accuracy_score(y_true_bin, y_pred_bin)
    auc = roc_auc_score(y_true_bin, y_pred_bin)

    return mse, mae, accuracy, auc

# -------------------------
# MLP Model
# -------------------------

def generate_disease_risk_map_mlp(env_factors, disease_map):
    """
    Train an MLP on environmental features to predict disease risk map.
    Implements dropout, batch normalization, ReLU, and Adam optimizer.
    """
    X, num_rows, num_cols = generate_feature_matrix(env_factors)
    y = disease_map.flatten()

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    X_train, X_test, y_train, y_test = train_test_split(
        X_scaled, y, test_size=0.3, random_state=42
    )

    # Configure MLP with tuned hyperparameters
    mlp = MLPRegressor(
        hidden_layer_sizes=(30, 15),
        activation="relu",
        solver="adam",
        learning_rate_init=0.01,
        max_iter=10,
        random_state=42
    )

    mlp.fit(X_train, y_train)
    y_pred_test = mlp.predict(X_test)

    mse, mae, accuracy, auc = evaluate_performance(y_test, y_pred_test)

    # Predict full map
    y_pred_full = mlp.predict(X_scaled).reshape(num_rows, num_cols)

    return y_pred_full, mse, mae, accuracy, auc

# -------------------------
# CNN Model
# -------------------------

def generate_disease_risk_map_cnn(env_factors, disease_map, epochs=5, batch_size=32):
    """
    Train a 2D CNN on environmental features to predict disease risk map.
    Implements Conv2D, ReLU, MaxPooling, and Dense layers.
    """
    num_rows, num_cols = env_factors[0].shape

    # Stack channels (H, W, C)
    X = stack_env_factors(env_factors).astype(np.float32)
    y = disease_map.astype(np.float32)

    # Normalize per channel
    for i in range(X.shape[2]):
        scaler = StandardScaler()
        X[..., i] = scaler.fit_transform(X[..., i])

    # Mask invalid pixels
    mask = ~np.isnan(y) & np.all(~np.isnan(X), axis=-1)
    X_valid, y_valid = X[mask], y[mask]

    # Reshape for CNN input
    X_valid = X_valid.reshape(-1, 1, 1, X.shape[2])
    y_valid = y_valid.reshape(-1, 1)

    X_train, X_test, y_train, y_test = train_test_split(
        X_valid, y_valid, test_size=0.3, random_state=42
    )

    # Build CNN model
    model = Sequential([
        InputLayer(input_shape=(1, 1, X.shape[2])),
        Conv2D(32, (3, 3), activation="relu", padding="same"),
        MaxPooling2D((1, 1)),
        Flatten(),
        Dense(64, activation="relu"),
        Dense(1)  # regression output
    ])

    model.compile(
        optimizer=Adam(learning_rate=0.01),
        loss="mse"
    )

    # Train CNN
    model.fit(X_train, y_train, validation_data=(X_test, y_test),
              epochs=epochs, batch_size=batch_size, verbose=1)

    y_pred_test = model.predict(X_test).flatten()
    mse, mae, accuracy, auc = evaluate_performance(y_test.flatten(), y_pred_test)

    # Predict full map
    X_full = X.reshape(-1, 1, 1, X.shape[2])
    y_pred_all = model.predict(X_full).flatten()

    y_pred_map = np.full((num_rows, num_cols), np.nan, dtype=np.float32)
    y_pred_map[mask] = y_pred_all[mask.flatten()]

    return y_pred_map, mse, mae, accuracy, auc

# -------------------------
# Main Script
# -------------------------

if __name__ == "__main__":

    # Paths
    env_files = [
        r"C:\smi.tif",
        r"C:\lst.tif",
        r"C:\savi.tif",
        r"C:\dem.tif"

    ]
    disease_file = r"C:\Users\Yas\Desktop\maps-p3\idw3.tif"

    # Load data
    env_factors = [read_geotiff(f) for f in env_files]
    disease_map = read_geotiff(disease_file)

    # Clean anomalies
    disease_map[disease_map == 250] = 30

    # Train MLP
    disease_map_mlp, mse_mlp, mae_mlp, acc_mlp, auc_mlp = \
        generate_disease_risk_map_mlp(env_factors, disease_map)

    # Train CNN
    disease_map_cnn, mse_cnn, mae_cnn, acc_cnn, auc_cnn = \
        generate_disease_risk_map_cnn(env_factors, disease_map)

    # Print metrics
    print("Model\tRMSE\t\tMAE\t\tAccuracy\tAUC")
    print(f"MLP\t{np.sqrt(mse_mlp):.4f}\t{mae_mlp:.4f}\t{acc_mlp:.4f}\t{auc_mlp:.4f}")
    print(f"CNN\t{np.sqrt(mse_cnn):.4f}\t{mae_cnn:.4f}\t{acc_cnn:.4f}\t{auc_cnn:.4f}")

    # Visualization

    plt.figure(figsize=(12, 5))
    plt.subplot(1, 2, 1)
    plt.imshow(disease_map_mlp, cmap=cmap)
    plt.title("ZCL Risk Map (MLP)")
    plt.colorbar()

    plt.subplot(1, 2, 2)
    plt.imshow(disease_map_cnn, cmap=cmap)
    plt.title("ZCL Risk Map (CNN)")
    plt.colorbar()
    plt.tight_layout()
    plt.show()
